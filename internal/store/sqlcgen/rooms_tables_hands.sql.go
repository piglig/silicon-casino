// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rooms_tables_hands.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRooms = `-- name: CountRooms :one
SELECT COUNT(1)::int
FROM rooms
`

func (q *Queries) CountRooms(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countRooms)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createHand = `-- name: CreateHand :exec
INSERT INTO hands (id, table_id)
VALUES ($1, $2)
`

type CreateHandParams struct {
	ID      string
	TableID string
}

func (q *Queries) CreateHand(ctx context.Context, arg CreateHandParams) error {
	_, err := q.db.Exec(ctx, createHand, arg.ID, arg.TableID)
	return err
}

const createRoom = `-- name: CreateRoom :exec
INSERT INTO rooms (id, name, min_buyin_cc, small_blind_cc, big_blind_cc, status)
VALUES ($1, $2, $3, $4, $5, 'active')
`

type CreateRoomParams struct {
	ID           string
	Name         string
	MinBuyinCc   int64
	SmallBlindCc int64
	BigBlindCc   int64
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) error {
	_, err := q.db.Exec(ctx, createRoom,
		arg.ID,
		arg.Name,
		arg.MinBuyinCc,
		arg.SmallBlindCc,
		arg.BigBlindCc,
	)
	return err
}

const createTable = `-- name: CreateTable :exec
INSERT INTO tables (id, room_id, status, small_blind_cc, big_blind_cc)
VALUES ($1, $2, $3, $4, $5)
`

type CreateTableParams struct {
	ID           string
	RoomID       pgtype.Text
	Status       string
	SmallBlindCc int64
	BigBlindCc   int64
}

func (q *Queries) CreateTable(ctx context.Context, arg CreateTableParams) error {
	_, err := q.db.Exec(ctx, createTable,
		arg.ID,
		arg.RoomID,
		arg.Status,
		arg.SmallBlindCc,
		arg.BigBlindCc,
	)
	return err
}

const endHand = `-- name: EndHand :exec
UPDATE hands
SET ended_at = now(),
    winner_agent_id = NULLIF($2::text, ''),
    pot_cc = $3,
    street_end = NULLIF($4::text, '')
WHERE id = $1
`

type EndHandParams struct {
	ID      string
	Column2 string
	PotCc   pgtype.Int8
	Column4 string
}

func (q *Queries) EndHand(ctx context.Context, arg EndHandParams) error {
	_, err := q.db.Exec(ctx, endHand,
		arg.ID,
		arg.Column2,
		arg.PotCc,
		arg.Column4,
	)
	return err
}

const getRoomByID = `-- name: GetRoomByID :one
SELECT id, name, min_buyin_cc, small_blind_cc, big_blind_cc, status, created_at
FROM rooms
WHERE id = $1
`

func (q *Queries) GetRoomByID(ctx context.Context, id string) (Room, error) {
	row := q.db.QueryRow(ctx, getRoomByID, id)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MinBuyinCc,
		&i.SmallBlindCc,
		&i.BigBlindCc,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const listRooms = `-- name: ListRooms :many
SELECT id, name, min_buyin_cc, small_blind_cc, big_blind_cc, status, created_at
FROM rooms
WHERE status = 'active'
ORDER BY min_buyin_cc ASC
`

func (q *Queries) ListRooms(ctx context.Context) ([]Room, error) {
	rows, err := q.db.Query(ctx, listRooms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MinBuyinCc,
			&i.SmallBlindCc,
			&i.BigBlindCc,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTables = `-- name: ListTables :many
SELECT id, room_id, status, small_blind_cc, big_blind_cc, created_at
FROM tables
WHERE status = 'active'
  AND ($1::text = '' OR room_id = $1)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListTablesParams struct {
	Column1 string
	Limit   int32
	Offset  int32
}

func (q *Queries) ListTables(ctx context.Context, arg ListTablesParams) ([]Table, error) {
	rows, err := q.db.Query(ctx, listTables, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Table{}
	for rows.Next() {
		var i Table
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.Status,
			&i.SmallBlindCc,
			&i.BigBlindCc,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordAction = `-- name: RecordAction :exec
INSERT INTO actions (id, hand_id, agent_id, action_type, amount_cc)
VALUES ($1, $2, $3, $4, $5)
`

type RecordActionParams struct {
	ID         string
	HandID     string
	AgentID    string
	ActionType string
	AmountCc   int64
}

func (q *Queries) RecordAction(ctx context.Context, arg RecordActionParams) error {
	_, err := q.db.Exec(ctx, recordAction,
		arg.ID,
		arg.HandID,
		arg.AgentID,
		arg.ActionType,
		arg.AmountCc,
	)
	return err
}
