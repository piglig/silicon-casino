// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: store.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const blacklistAgent = `-- name: BlacklistAgent :exec
INSERT INTO agent_blacklist (agent_id, reason)
VALUES ($1, $2)
ON CONFLICT (agent_id) DO UPDATE
SET reason = EXCLUDED.reason, created_at = now()
`

type BlacklistAgentParams struct {
	AgentID string
	Reason  string
}

func (q *Queries) BlacklistAgent(ctx context.Context, arg BlacklistAgentParams) error {
	_, err := q.db.Exec(ctx, blacklistAgent, arg.AgentID, arg.Reason)
	return err
}

const countRooms = `-- name: CountRooms :one
SELECT COUNT(1)::int
FROM rooms
`

func (q *Queries) CountRooms(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countRooms)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createAgent = `-- name: CreateAgent :exec
INSERT INTO agents (id, name, api_key_hash, status) VALUES ($1, $2, $3, 'pending')
`

type CreateAgentParams struct {
	ID         string
	Name       string
	ApiKeyHash string
}

func (q *Queries) CreateAgent(ctx context.Context, arg CreateAgentParams) error {
	_, err := q.db.Exec(ctx, createAgent, arg.ID, arg.Name, arg.ApiKeyHash)
	return err
}

const createAgentClaim = `-- name: CreateAgentClaim :exec
INSERT INTO agent_claims (id, agent_id, claim_code, status)
VALUES ($1, $2, $3, 'pending')
`

type CreateAgentClaimParams struct {
	ID        string
	AgentID   string
	ClaimCode string
}

func (q *Queries) CreateAgentClaim(ctx context.Context, arg CreateAgentClaimParams) error {
	_, err := q.db.Exec(ctx, createAgentClaim, arg.ID, arg.AgentID, arg.ClaimCode)
	return err
}

const createAgentKey = `-- name: CreateAgentKey :exec
INSERT INTO agent_keys (id, agent_id, provider, api_key_hash, status)
VALUES ($1, $2, $3, $4, 'active')
`

type CreateAgentKeyParams struct {
	ID         string
	AgentID    string
	Provider   string
	ApiKeyHash string
}

func (q *Queries) CreateAgentKey(ctx context.Context, arg CreateAgentKeyParams) error {
	_, err := q.db.Exec(ctx, createAgentKey,
		arg.ID,
		arg.AgentID,
		arg.Provider,
		arg.ApiKeyHash,
	)
	return err
}

const createHand = `-- name: CreateHand :exec
INSERT INTO hands (id, table_id)
VALUES ($1, $2)
`

type CreateHandParams struct {
	ID      string
	TableID string
}

func (q *Queries) CreateHand(ctx context.Context, arg CreateHandParams) error {
	_, err := q.db.Exec(ctx, createHand, arg.ID, arg.TableID)
	return err
}

const createRoom = `-- name: CreateRoom :exec
INSERT INTO rooms (id, name, min_buyin_cc, small_blind_cc, big_blind_cc, status)
VALUES ($1, $2, $3, $4, $5, 'active')
`

type CreateRoomParams struct {
	ID           string
	Name         string
	MinBuyinCc   int64
	SmallBlindCc int64
	BigBlindCc   int64
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) error {
	_, err := q.db.Exec(ctx, createRoom,
		arg.ID,
		arg.Name,
		arg.MinBuyinCc,
		arg.SmallBlindCc,
		arg.BigBlindCc,
	)
	return err
}

const createTable = `-- name: CreateTable :exec
INSERT INTO tables (id, room_id, status, small_blind_cc, big_blind_cc)
VALUES ($1, $2, $3, $4, $5)
`

type CreateTableParams struct {
	ID           string
	RoomID       pgtype.Text
	Status       string
	SmallBlindCc int64
	BigBlindCc   int64
}

func (q *Queries) CreateTable(ctx context.Context, arg CreateTableParams) error {
	_, err := q.db.Exec(ctx, createTable,
		arg.ID,
		arg.RoomID,
		arg.Status,
		arg.SmallBlindCc,
		arg.BigBlindCc,
	)
	return err
}

const endHand = `-- name: EndHand :exec
UPDATE hands
SET ended_at = now()
WHERE id = $1
`

func (q *Queries) EndHand(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, endHand, id)
	return err
}

const ensureAccount = `-- name: EnsureAccount :exec
INSERT INTO accounts (agent_id, balance_cc)
VALUES ($1, $2)
ON CONFLICT (agent_id) DO NOTHING
`

type EnsureAccountParams struct {
	AgentID   string
	BalanceCc int64
}

func (q *Queries) EnsureAccount(ctx context.Context, arg EnsureAccountParams) error {
	_, err := q.db.Exec(ctx, ensureAccount, arg.AgentID, arg.BalanceCc)
	return err
}

const ensureDefaultProviderRate = `-- name: EnsureDefaultProviderRate :exec
INSERT INTO provider_rates (provider, price_per_1k_tokens_usd, cc_per_usd, weight)
VALUES ($1, $2, $3, $4)
ON CONFLICT (provider) DO NOTHING
`

type EnsureDefaultProviderRateParams struct {
	Provider            string
	PricePer1kTokensUsd float64
	CcPerUsd            float64
	Weight              float64
}

func (q *Queries) EnsureDefaultProviderRate(ctx context.Context, arg EnsureDefaultProviderRateParams) error {
	_, err := q.db.Exec(ctx, ensureDefaultProviderRate,
		arg.Provider,
		arg.PricePer1kTokensUsd,
		arg.CcPerUsd,
		arg.Weight,
	)
	return err
}

const getAccountBalance = `-- name: GetAccountBalance :one
SELECT balance_cc
FROM accounts
WHERE agent_id = $1
`

func (q *Queries) GetAccountBalance(ctx context.Context, agentID string) (int64, error) {
	row := q.db.QueryRow(ctx, getAccountBalance, agentID)
	var balance_cc int64
	err := row.Scan(&balance_cc)
	return balance_cc, err
}

const getAccountBalanceForUpdate = `-- name: GetAccountBalanceForUpdate :one
SELECT balance_cc
FROM accounts
WHERE agent_id = $1
FOR UPDATE
`

func (q *Queries) GetAccountBalanceForUpdate(ctx context.Context, agentID string) (int64, error) {
	row := q.db.QueryRow(ctx, getAccountBalanceForUpdate, agentID)
	var balance_cc int64
	err := row.Scan(&balance_cc)
	return balance_cc, err
}

const getAgentByAPIKeyHash = `-- name: GetAgentByAPIKeyHash :one
SELECT id, name, api_key_hash, status, created_at
FROM agents
WHERE api_key_hash = $1
`

func (q *Queries) GetAgentByAPIKeyHash(ctx context.Context, apiKeyHash string) (Agent, error) {
	row := q.db.QueryRow(ctx, getAgentByAPIKeyHash, apiKeyHash)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ApiKeyHash,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getAgentByID = `-- name: GetAgentByID :one
SELECT id, name, api_key_hash, status, created_at
FROM agents
WHERE id = $1
`

func (q *Queries) GetAgentByID(ctx context.Context, id string) (Agent, error) {
	row := q.db.QueryRow(ctx, getAgentByID, id)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ApiKeyHash,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getAgentClaimByAgent = `-- name: GetAgentClaimByAgent :one
SELECT id, agent_id, claim_code, status, created_at
FROM agent_claims
WHERE agent_id = $1
`

func (q *Queries) GetAgentClaimByAgent(ctx context.Context, agentID string) (AgentClaim, error) {
	row := q.db.QueryRow(ctx, getAgentClaimByAgent, agentID)
	var i AgentClaim
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.ClaimCode,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getAgentKeyByHash = `-- name: GetAgentKeyByHash :one
SELECT id, agent_id, provider, api_key_hash, status, created_at
FROM agent_keys
WHERE api_key_hash = $1
`

func (q *Queries) GetAgentKeyByHash(ctx context.Context, apiKeyHash string) (AgentKey, error) {
	row := q.db.QueryRow(ctx, getAgentKeyByHash, apiKeyHash)
	var i AgentKey
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.Provider,
		&i.ApiKeyHash,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getProviderRate = `-- name: GetProviderRate :one
SELECT provider, price_per_1k_tokens_usd, cc_per_usd, weight, updated_at
FROM provider_rates
WHERE provider = $1
`

func (q *Queries) GetProviderRate(ctx context.Context, provider string) (ProviderRate, error) {
	row := q.db.QueryRow(ctx, getProviderRate, provider)
	var i ProviderRate
	err := row.Scan(
		&i.Provider,
		&i.PricePer1kTokensUsd,
		&i.CcPerUsd,
		&i.Weight,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoom = `-- name: GetRoom :one
SELECT id, name, min_buyin_cc, small_blind_cc, big_blind_cc, status, created_at
FROM rooms
WHERE id = $1
`

func (q *Queries) GetRoom(ctx context.Context, id string) (Room, error) {
	row := q.db.QueryRow(ctx, getRoom, id)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MinBuyinCc,
		&i.SmallBlindCc,
		&i.BigBlindCc,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const insertLedgerEntry = `-- name: InsertLedgerEntry :exec
INSERT INTO ledger_entries (id, agent_id, type, amount_cc, ref_type, ref_id)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertLedgerEntryParams struct {
	ID       string
	AgentID  string
	Type     string
	AmountCc int64
	RefType  string
	RefID    string
}

func (q *Queries) InsertLedgerEntry(ctx context.Context, arg InsertLedgerEntryParams) error {
	_, err := q.db.Exec(ctx, insertLedgerEntry,
		arg.ID,
		arg.AgentID,
		arg.Type,
		arg.AmountCc,
		arg.RefType,
		arg.RefID,
	)
	return err
}

const isAgentBlacklisted = `-- name: IsAgentBlacklisted :one
SELECT reason
FROM agent_blacklist
WHERE agent_id = $1
`

func (q *Queries) IsAgentBlacklisted(ctx context.Context, agentID string) (string, error) {
	row := q.db.QueryRow(ctx, isAgentBlacklisted, agentID)
	var reason string
	err := row.Scan(&reason)
	return reason, err
}

const lastSuccessfulKeyBindAt = `-- name: LastSuccessfulKeyBindAt :one
SELECT created_at
FROM agent_key_attempts
WHERE agent_id = $1 AND status = 'success'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) LastSuccessfulKeyBindAt(ctx context.Context, agentID string) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, lastSuccessfulKeyBindAt, agentID)
	var created_at pgtype.Timestamptz
	err := row.Scan(&created_at)
	return created_at, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT agent_id, balance_cc, updated_at
FROM accounts
WHERE ($1::text = '' OR agent_id = $1)
ORDER BY updated_at DESC
LIMIT $2 OFFSET $3
`

type ListAccountsParams struct {
	Column1 string
	Limit   int32
	Offset  int32
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(&i.AgentID, &i.BalanceCc, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgentKeyAttemptStatuses = `-- name: ListAgentKeyAttemptStatuses :many
SELECT status
FROM agent_key_attempts
WHERE agent_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAgentKeyAttemptStatuses(ctx context.Context, agentID string) ([]string, error) {
	rows, err := q.db.Query(ctx, listAgentKeyAttemptStatuses, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var status string
		if err := rows.Scan(&status); err != nil {
			return nil, err
		}
		items = append(items, status)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgents = `-- name: ListAgents :many
SELECT id, name, api_key_hash, status, created_at
FROM agents
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAgentsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAgents(ctx context.Context, arg ListAgentsParams) ([]Agent, error) {
	rows, err := q.db.Query(ctx, listAgents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Agent{}
	for rows.Next() {
		var i Agent
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ApiKeyHash,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeaderboard = `-- name: ListLeaderboard :many
SELECT a.id, a.name, COALESCE(SUM(l.amount_cc), 0)::bigint AS net_cc
FROM agents a
LEFT JOIN ledger_entries l ON l.agent_id = a.id
GROUP BY a.id, a.name
ORDER BY net_cc DESC
LIMIT $1 OFFSET $2
`

type ListLeaderboardParams struct {
	Limit  int32
	Offset int32
}

type ListLeaderboardRow struct {
	ID    string
	Name  string
	NetCc int64
}

func (q *Queries) ListLeaderboard(ctx context.Context, arg ListLeaderboardParams) ([]ListLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, listLeaderboard, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLeaderboardRow{}
	for rows.Next() {
		var i ListLeaderboardRow
		if err := rows.Scan(&i.ID, &i.Name, &i.NetCc); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLedgerEntries = `-- name: ListLedgerEntries :many
SELECT id, agent_id, type, amount_cc, ref_type, ref_id, created_at
FROM ledger_entries
WHERE ($1::text = '' OR agent_id = $1)
  AND ($2::text = '' OR (ref_type = 'hand' AND ref_id = $2))
  AND ($3::timestamptz IS NULL OR created_at >= $3)
  AND ($4::timestamptz IS NULL OR created_at <= $4)
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListLedgerEntriesParams struct {
	Column1 string
	Column2 string
	Column3 pgtype.Timestamptz
	Column4 pgtype.Timestamptz
	Limit   int32
	Offset  int32
}

func (q *Queries) ListLedgerEntries(ctx context.Context, arg ListLedgerEntriesParams) ([]LedgerEntry, error) {
	rows, err := q.db.Query(ctx, listLedgerEntries,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LedgerEntry{}
	for rows.Next() {
		var i LedgerEntry
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.Type,
			&i.AmountCc,
			&i.RefType,
			&i.RefID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProviderRates = `-- name: ListProviderRates :many
SELECT provider, price_per_1k_tokens_usd, cc_per_usd, weight, updated_at
FROM provider_rates
ORDER BY provider ASC
`

func (q *Queries) ListProviderRates(ctx context.Context) ([]ProviderRate, error) {
	rows, err := q.db.Query(ctx, listProviderRates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProviderRate{}
	for rows.Next() {
		var i ProviderRate
		if err := rows.Scan(
			&i.Provider,
			&i.PricePer1kTokensUsd,
			&i.CcPerUsd,
			&i.Weight,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRooms = `-- name: ListRooms :many
SELECT id, name, min_buyin_cc, small_blind_cc, big_blind_cc, status, created_at
FROM rooms
WHERE status = 'active'
ORDER BY min_buyin_cc ASC
`

func (q *Queries) ListRooms(ctx context.Context) ([]Room, error) {
	rows, err := q.db.Query(ctx, listRooms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MinBuyinCc,
			&i.SmallBlindCc,
			&i.BigBlindCc,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTables = `-- name: ListTables :many
SELECT id, room_id, status, small_blind_cc, big_blind_cc, created_at
FROM tables
WHERE status = 'active'
  AND ($1::text = '' OR room_id = $1)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListTablesParams struct {
	Column1 string
	Limit   int32
	Offset  int32
}

func (q *Queries) ListTables(ctx context.Context, arg ListTablesParams) ([]Table, error) {
	rows, err := q.db.Query(ctx, listTables, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Table{}
	for rows.Next() {
		var i Table
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.Status,
			&i.SmallBlindCc,
			&i.BigBlindCc,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAgentClaimClaimed = `-- name: MarkAgentClaimClaimed :exec
UPDATE agent_claims
SET status = 'claimed'
WHERE agent_id = $1
`

func (q *Queries) MarkAgentClaimClaimed(ctx context.Context, agentID string) error {
	_, err := q.db.Exec(ctx, markAgentClaimClaimed, agentID)
	return err
}

const markAgentStatusClaimed = `-- name: MarkAgentStatusClaimed :exec
UPDATE agents
SET status = 'claimed'
WHERE id = $1
`

func (q *Queries) MarkAgentStatusClaimed(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, markAgentStatusClaimed, id)
	return err
}

const recordAction = `-- name: RecordAction :exec
INSERT INTO actions (id, hand_id, agent_id, action_type, amount_cc)
VALUES ($1, $2, $3, $4, $5)
`

type RecordActionParams struct {
	ID         string
	HandID     string
	AgentID    string
	ActionType string
	AmountCc   int64
}

func (q *Queries) RecordAction(ctx context.Context, arg RecordActionParams) error {
	_, err := q.db.Exec(ctx, recordAction,
		arg.ID,
		arg.HandID,
		arg.AgentID,
		arg.ActionType,
		arg.AmountCc,
	)
	return err
}

const recordAgentKeyAttempt = `-- name: RecordAgentKeyAttempt :exec
INSERT INTO agent_key_attempts (id, agent_id, provider, status)
VALUES ($1, $2, $3, $4)
`

type RecordAgentKeyAttemptParams struct {
	ID       string
	AgentID  string
	Provider string
	Status   string
}

func (q *Queries) RecordAgentKeyAttempt(ctx context.Context, arg RecordAgentKeyAttemptParams) error {
	_, err := q.db.Exec(ctx, recordAgentKeyAttempt,
		arg.ID,
		arg.AgentID,
		arg.Provider,
		arg.Status,
	)
	return err
}

const recordProxyCall = `-- name: RecordProxyCall :exec
INSERT INTO proxy_calls (id, agent_id, prompt_tokens, completion_tokens, total_tokens, model, provider, cost_cc)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type RecordProxyCallParams struct {
	ID               string
	AgentID          string
	PromptTokens     int32
	CompletionTokens int32
	TotalTokens      pgtype.Int4
	Model            pgtype.Text
	Provider         pgtype.Text
	CostCc           int64
}

func (q *Queries) RecordProxyCall(ctx context.Context, arg RecordProxyCallParams) error {
	_, err := q.db.Exec(ctx, recordProxyCall,
		arg.ID,
		arg.AgentID,
		arg.PromptTokens,
		arg.CompletionTokens,
		arg.TotalTokens,
		arg.Model,
		arg.Provider,
		arg.CostCc,
	)
	return err
}

const updateAccountBalance = `-- name: UpdateAccountBalance :exec
UPDATE accounts
SET balance_cc = $1, updated_at = now()
WHERE agent_id = $2
`

type UpdateAccountBalanceParams struct {
	BalanceCc int64
	AgentID   string
}

func (q *Queries) UpdateAccountBalance(ctx context.Context, arg UpdateAccountBalanceParams) error {
	_, err := q.db.Exec(ctx, updateAccountBalance, arg.BalanceCc, arg.AgentID)
	return err
}

const upsertProviderRate = `-- name: UpsertProviderRate :exec
INSERT INTO provider_rates (provider, price_per_1k_tokens_usd, cc_per_usd, weight)
VALUES ($1, $2, $3, $4)
ON CONFLICT (provider) DO UPDATE
SET price_per_1k_tokens_usd = EXCLUDED.price_per_1k_tokens_usd,
    cc_per_usd = EXCLUDED.cc_per_usd,
    weight = EXCLUDED.weight,
    updated_at = now()
`

type UpsertProviderRateParams struct {
	Provider            string
	PricePer1kTokensUsd float64
	CcPerUsd            float64
	Weight              float64
}

func (q *Queries) UpsertProviderRate(ctx context.Context, arg UpsertProviderRateParams) error {
	_, err := q.db.Exec(ctx, upsertProviderRate,
		arg.Provider,
		arg.PricePer1kTokensUsd,
		arg.CcPerUsd,
		arg.Weight,
	)
	return err
}
