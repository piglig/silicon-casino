// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ledger.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertLedgerEntry = `-- name: InsertLedgerEntry :exec
INSERT INTO ledger_entries (id, agent_id, type, amount_cc, ref_type, ref_id)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertLedgerEntryParams struct {
	ID       string
	AgentID  string
	Type     string
	AmountCc int64
	RefType  string
	RefID    string
}

func (q *Queries) InsertLedgerEntry(ctx context.Context, arg InsertLedgerEntryParams) error {
	_, err := q.db.Exec(ctx, insertLedgerEntry,
		arg.ID,
		arg.AgentID,
		arg.Type,
		arg.AmountCc,
		arg.RefType,
		arg.RefID,
	)
	return err
}

const listLeaderboard = `-- name: ListLeaderboard :many
WITH hand_ledger AS (
  SELECT
    l.agent_id,
    l.ref_id AS hand_id,
    SUM(l.amount_cc)::bigint AS hand_net_cc
  FROM ledger_entries l
  WHERE l.ref_type = 'hand'
    AND l.type IN ('blind_debit', 'bet_debit', 'pot_credit')
  GROUP BY l.agent_id, l.ref_id
),
scoped_hand_ledger AS (
  SELECT
    hl.agent_id,
    hl.hand_id,
    hl.hand_net_cc,
    h.winner_agent_id,
    h.ended_at,
    t.big_blind_cc
  FROM hand_ledger hl
  JOIN hands h ON h.id = hl.hand_id
  JOIN tables t ON t.id = h.table_id
  JOIN rooms r ON r.id = t.room_id
  WHERE h.ended_at IS NOT NULL
    AND ($1::timestamptz IS NULL OR h.ended_at >= $1::timestamptz)
    AND ($2::text = 'all' OR lower(r.name) = $2::text)
),
aggregated AS (
  SELECT
    shl.agent_id,
    COUNT(*)::int AS hands_played,
    SUM(CASE WHEN shl.winner_agent_id = shl.agent_id THEN 1 ELSE 0 END)::int AS wins,
    SUM(shl.hand_net_cc)::bigint AS net_cc_from_play,
    SUM(shl.hand_net_cc::numeric / NULLIF(shl.big_blind_cc::numeric, 0)) AS net_bb,
    MAX(shl.ended_at) AS last_active_at
  FROM scoped_hand_ledger shl
  GROUP BY shl.agent_id
)
SELECT
  a.id AS agent_id,
  a.name,
  COALESCE((agg.net_bb / agg.hands_played::numeric) * 100, 0)::numeric AS bb_per_100,
  agg.net_cc_from_play,
  agg.hands_played,
  COALESCE(agg.wins::numeric / NULLIF(agg.hands_played::numeric, 0), 0)::numeric AS win_rate,
  COALESCE(LEAST(1.0::numeric, agg.hands_played::numeric / 500.0), 0)::numeric AS confidence_factor,
  (
    COALESCE((agg.net_bb / agg.hands_played::numeric) * 100, 0)::numeric *
    COALESCE(LEAST(1.0::numeric, agg.hands_played::numeric / 500.0), 0)::numeric
  )::numeric AS score,
  agg.last_active_at
FROM aggregated agg
JOIN agents a ON a.id = agg.agent_id
ORDER BY
  CASE WHEN $3::text = 'score' THEN (
    COALESCE((agg.net_bb / agg.hands_played::numeric) * 100, 0)::numeric *
    COALESCE(LEAST(1.0::numeric, agg.hands_played::numeric / 500.0), 0)::numeric
  ) END DESC,
  CASE WHEN $3::text = 'net_cc_from_play' THEN agg.net_cc_from_play::numeric END DESC,
  CASE WHEN $3::text = 'hands_played' THEN agg.hands_played::numeric END DESC,
  CASE WHEN $3::text = 'win_rate' THEN COALESCE(agg.wins::numeric / NULLIF(agg.hands_played::numeric, 0), 0)::numeric END DESC,
  agg.hands_played DESC,
  agg.last_active_at DESC,
  a.id ASC
LIMIT $5 OFFSET $4
`

type ListLeaderboardParams struct {
	WindowStart pgtype.Timestamptz
	RoomScope   string
	SortBy      string
	OffsetRows  int32
	LimitRows   int32
}

type ListLeaderboardRow struct {
	AgentID          string
	Name             string
	BbPer100         float64
	NetCcFromPlay    int64
	HandsPlayed      int32
	WinRate          float64
	ConfidenceFactor float64
	Score            float64
	LastActiveAt     pgtype.Timestamptz
}

func (q *Queries) ListLeaderboard(ctx context.Context, arg ListLeaderboardParams) ([]ListLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, listLeaderboard,
		arg.WindowStart,
		arg.RoomScope,
		arg.SortBy,
		arg.OffsetRows,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLeaderboardRow{}
	for rows.Next() {
		var i ListLeaderboardRow
		if err := rows.Scan(
			&i.AgentID,
			&i.Name,
			&i.BbPer100,
			&i.NetCcFromPlay,
			&i.HandsPlayed,
			&i.WinRate,
			&i.ConfidenceFactor,
			&i.Score,
			&i.LastActiveAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLedgerEntries = `-- name: ListLedgerEntries :many
SELECT id, agent_id, type, amount_cc, ref_type, ref_id, created_at
FROM ledger_entries
WHERE ($1::text = '' OR agent_id = $1::text)
  AND ($2::text = '' OR (ref_type = 'hand' AND ref_id = $2::text))
  AND ($3::timestamptz IS NULL OR created_at >= $3::timestamptz)
  AND ($4::timestamptz IS NULL OR created_at <= $4::timestamptz)
ORDER BY created_at DESC
LIMIT $6 OFFSET $5
`

type ListLedgerEntriesParams struct {
	AgentID    string
	HandID     string
	FromTs     pgtype.Timestamptz
	ToTs       pgtype.Timestamptz
	OffsetRows int32
	LimitRows  int32
}

func (q *Queries) ListLedgerEntries(ctx context.Context, arg ListLedgerEntriesParams) ([]LedgerEntry, error) {
	rows, err := q.db.Query(ctx, listLedgerEntries,
		arg.AgentID,
		arg.HandID,
		arg.FromTs,
		arg.ToTs,
		arg.OffsetRows,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LedgerEntry{}
	for rows.Next() {
		var i LedgerEntry
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.Type,
			&i.AmountCc,
			&i.RefType,
			&i.RefID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
