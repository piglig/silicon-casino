// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: replay.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getHandByID = `-- name: GetHandByID :one
SELECT id, table_id, winner_agent_id, pot_cc, street_end, started_at, ended_at
FROM hands
WHERE id = $1
`

func (q *Queries) GetHandByID(ctx context.Context, id string) (Hand, error) {
	row := q.db.QueryRow(ctx, getHandByID, id)
	var i Hand
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.WinnerAgentID,
		&i.PotCc,
		&i.StreetEnd,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const getLatestTableReplaySnapshotAtOrBefore = `-- name: GetLatestTableReplaySnapshotAtOrBefore :one
SELECT id, table_id, at_global_seq, state_blob, schema_version, created_at
FROM table_replay_snapshots
WHERE table_id = $1
  AND at_global_seq <= $2
ORDER BY at_global_seq DESC
LIMIT 1
`

type GetLatestTableReplaySnapshotAtOrBeforeParams struct {
	TableID     string
	AtGlobalSeq int64
}

func (q *Queries) GetLatestTableReplaySnapshotAtOrBefore(ctx context.Context, arg GetLatestTableReplaySnapshotAtOrBeforeParams) (TableReplaySnapshot, error) {
	row := q.db.QueryRow(ctx, getLatestTableReplaySnapshotAtOrBefore, arg.TableID, arg.AtGlobalSeq)
	var i TableReplaySnapshot
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.AtGlobalSeq,
		&i.StateBlob,
		&i.SchemaVersion,
		&i.CreatedAt,
	)
	return i, err
}

const getTableReplayLastSeq = `-- name: GetTableReplayLastSeq :one
SELECT COALESCE(MAX(global_seq), 0)::bigint
FROM table_replay_events
WHERE table_id = $1
`

func (q *Queries) GetTableReplayLastSeq(ctx context.Context, tableID string) (int64, error) {
	row := q.db.QueryRow(ctx, getTableReplayLastSeq, tableID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const insertTableReplayEvent = `-- name: InsertTableReplayEvent :exec
INSERT INTO table_replay_events (
  id, table_id, hand_id, global_seq, hand_seq, event_type, actor_agent_id, payload, schema_version
)
VALUES (
  $1,
  $2,
  NULLIF($3::text, ''),
  $4,
  $5,
  $6,
  NULLIF($7::text, ''),
  $8::jsonb,
  $9
)
`

type InsertTableReplayEventParams struct {
	ID            string
	TableID       string
	HandID        string
	GlobalSeq     int64
	HandSeq       pgtype.Int4
	EventType     string
	ActorAgentID  string
	Payload       []byte
	SchemaVersion int32
}

func (q *Queries) InsertTableReplayEvent(ctx context.Context, arg InsertTableReplayEventParams) error {
	_, err := q.db.Exec(ctx, insertTableReplayEvent,
		arg.ID,
		arg.TableID,
		arg.HandID,
		arg.GlobalSeq,
		arg.HandSeq,
		arg.EventType,
		arg.ActorAgentID,
		arg.Payload,
		arg.SchemaVersion,
	)
	return err
}

const insertTableReplaySnapshot = `-- name: InsertTableReplaySnapshot :exec
INSERT INTO table_replay_snapshots (id, table_id, at_global_seq, state_blob, schema_version)
VALUES (
  $1,
  $2,
  $3,
  $4::jsonb,
  $5
)
`

type InsertTableReplaySnapshotParams struct {
	ID            string
	TableID       string
	AtGlobalSeq   int64
	StateBlob     []byte
	SchemaVersion int32
}

func (q *Queries) InsertTableReplaySnapshot(ctx context.Context, arg InsertTableReplaySnapshotParams) error {
	_, err := q.db.Exec(ctx, insertTableReplaySnapshot,
		arg.ID,
		arg.TableID,
		arg.AtGlobalSeq,
		arg.StateBlob,
		arg.SchemaVersion,
	)
	return err
}

const listAgentTables = `-- name: ListAgentTables :many
SELECT
  t.id,
  t.room_id,
  t.status,
  t.small_blind_cc,
  t.big_blind_cc,
  t.created_at,
  MAX(h.ended_at) AS last_hand_ended_at
FROM tables t
JOIN agent_sessions s ON s.table_id = t.id
LEFT JOIN hands h ON h.table_id = t.id
WHERE s.agent_id = $1
GROUP BY t.id, t.room_id, t.status, t.small_blind_cc, t.big_blind_cc, t.created_at
ORDER BY MAX(h.started_at) DESC NULLS LAST, t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListAgentTablesParams struct {
	AgentID string
	Limit   int32
	Offset  int32
}

type ListAgentTablesRow struct {
	ID              string
	RoomID          pgtype.Text
	Status          string
	SmallBlindCc    int64
	BigBlindCc      int64
	CreatedAt       pgtype.Timestamptz
	LastHandEndedAt interface{}
}

func (q *Queries) ListAgentTables(ctx context.Context, arg ListAgentTablesParams) ([]ListAgentTablesRow, error) {
	rows, err := q.db.Query(ctx, listAgentTables, arg.AgentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAgentTablesRow{}
	for rows.Next() {
		var i ListAgentTablesRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.Status,
			&i.SmallBlindCc,
			&i.BigBlindCc,
			&i.CreatedAt,
			&i.LastHandEndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHandsByAgentID = `-- name: ListHandsByAgentID :many
SELECT h.id, h.table_id, h.winner_agent_id, h.pot_cc, h.street_end, h.started_at, h.ended_at
FROM hands h
JOIN actions a ON a.hand_id = h.id
WHERE a.agent_id = $1
GROUP BY h.id, h.table_id, h.winner_agent_id, h.pot_cc, h.street_end, h.started_at, h.ended_at
ORDER BY h.started_at DESC
LIMIT $2 OFFSET $3
`

type ListHandsByAgentIDParams struct {
	AgentID string
	Limit   int32
	Offset  int32
}

func (q *Queries) ListHandsByAgentID(ctx context.Context, arg ListHandsByAgentIDParams) ([]Hand, error) {
	rows, err := q.db.Query(ctx, listHandsByAgentID, arg.AgentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Hand{}
	for rows.Next() {
		var i Hand
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.WinnerAgentID,
			&i.PotCc,
			&i.StreetEnd,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHandsByTableID = `-- name: ListHandsByTableID :many
SELECT id, table_id, winner_agent_id, pot_cc, street_end, started_at, ended_at
FROM hands
WHERE table_id = $1
ORDER BY started_at ASC
`

func (q *Queries) ListHandsByTableID(ctx context.Context, tableID string) ([]Hand, error) {
	rows, err := q.db.Query(ctx, listHandsByTableID, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Hand{}
	for rows.Next() {
		var i Hand
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.WinnerAgentID,
			&i.PotCc,
			&i.StreetEnd,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTableHistory = `-- name: ListTableHistory :many
SELECT
  t.id,
  t.room_id,
  t.status,
  t.small_blind_cc,
  t.big_blind_cc,
  t.created_at,
  MAX(h.ended_at) AS last_hand_ended_at
FROM tables t
LEFT JOIN hands h ON h.table_id = t.id
WHERE ($1::text = '' OR t.room_id = $1::text)
  AND (
    $2::text = ''
    OR EXISTS (
      SELECT 1
      FROM agent_sessions s
      WHERE s.table_id = t.id AND s.agent_id = $2::text
    )
  )
GROUP BY t.id, t.room_id, t.status, t.small_blind_cc, t.big_blind_cc, t.created_at
ORDER BY MAX(h.started_at) DESC NULLS LAST, t.created_at DESC
LIMIT $4 OFFSET $3
`

type ListTableHistoryParams struct {
	RoomID     string
	AgentID    string
	OffsetRows int32
	LimitRows  int32
}

type ListTableHistoryRow struct {
	ID              string
	RoomID          pgtype.Text
	Status          string
	SmallBlindCc    int64
	BigBlindCc      int64
	CreatedAt       pgtype.Timestamptz
	LastHandEndedAt interface{}
}

func (q *Queries) ListTableHistory(ctx context.Context, arg ListTableHistoryParams) ([]ListTableHistoryRow, error) {
	rows, err := q.db.Query(ctx, listTableHistory,
		arg.RoomID,
		arg.AgentID,
		arg.OffsetRows,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTableHistoryRow{}
	for rows.Next() {
		var i ListTableHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.Status,
			&i.SmallBlindCc,
			&i.BigBlindCc,
			&i.CreatedAt,
			&i.LastHandEndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTableReplayEventsFromSeq = `-- name: ListTableReplayEventsFromSeq :many
SELECT id, table_id, hand_id, global_seq, hand_seq, event_type, actor_agent_id, payload, schema_version, created_at
FROM table_replay_events
WHERE table_id = $1
  AND global_seq >= $2
ORDER BY global_seq ASC
LIMIT $3
`

type ListTableReplayEventsFromSeqParams struct {
	TableID   string
	GlobalSeq int64
	Limit     int32
}

func (q *Queries) ListTableReplayEventsFromSeq(ctx context.Context, arg ListTableReplayEventsFromSeqParams) ([]TableReplayEvent, error) {
	rows, err := q.db.Query(ctx, listTableReplayEventsFromSeq, arg.TableID, arg.GlobalSeq, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableReplayEvent{}
	for rows.Next() {
		var i TableReplayEvent
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.HandID,
			&i.GlobalSeq,
			&i.HandSeq,
			&i.EventType,
			&i.ActorAgentID,
			&i.Payload,
			&i.SchemaVersion,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
