// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: agent_sessions.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const closeAgentSession = `-- name: CloseAgentSession :execrows
UPDATE agent_sessions
SET status = 'closed', closed_at = now()
WHERE id = $1 AND status <> 'closed'
`

func (q *Queries) CloseAgentSession(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, closeAgentSession, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const closeAgentSessionsByTableID = `-- name: CloseAgentSessionsByTableID :execrows
UPDATE agent_sessions
SET status = 'closed', closed_at = now()
WHERE table_id = $1::text AND status <> 'closed'
`

func (q *Queries) CloseAgentSessionsByTableID(ctx context.Context, dollar_1 string) (int64, error) {
	result, err := q.db.Exec(ctx, closeAgentSessionsByTableID, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const countAgentActionRequestsBySessionAndRequest = `-- name: CountAgentActionRequestsBySessionAndRequest :one
SELECT COUNT(*)::int
FROM agent_action_requests
WHERE session_id = $1 AND request_id = $2
`

type CountAgentActionRequestsBySessionAndRequestParams struct {
	SessionID string
	RequestID string
}

func (q *Queries) CountAgentActionRequestsBySessionAndRequest(ctx context.Context, arg CountAgentActionRequestsBySessionAndRequestParams) (int32, error) {
	row := q.db.QueryRow(ctx, countAgentActionRequestsBySessionAndRequest, arg.SessionID, arg.RequestID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countAgentSessions = `-- name: CountAgentSessions :one
SELECT COUNT(*)::int
FROM agent_sessions
`

func (q *Queries) CountAgentSessions(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countAgentSessions)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createAgentSession = `-- name: CreateAgentSession :exec
INSERT INTO agent_sessions (id, agent_id, room_id, table_id, seat_id, join_mode, status, expires_at)
VALUES (
  $1,
  $2,
  $3,
  NULLIF($4::text, ''),
  $5,
  $6,
  $7,
  $8
)
`

type CreateAgentSessionParams struct {
	ID        string
	AgentID   string
	RoomID    string
	TableID   string
	SeatID    pgtype.Int4
	JoinMode  string
	Status    string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreateAgentSession(ctx context.Context, arg CreateAgentSessionParams) error {
	_, err := q.db.Exec(ctx, createAgentSession,
		arg.ID,
		arg.AgentID,
		arg.RoomID,
		arg.TableID,
		arg.SeatID,
		arg.JoinMode,
		arg.Status,
		arg.ExpiresAt,
	)
	return err
}

const getAgentActionRequestBySessionAndRequest = `-- name: GetAgentActionRequestBySessionAndRequest :one
SELECT id, session_id, request_id, turn_id, action_type, amount_cc, thought_log, accepted, reason, created_at
FROM agent_action_requests
WHERE session_id = $1 AND request_id = $2
`

type GetAgentActionRequestBySessionAndRequestParams struct {
	SessionID string
	RequestID string
}

func (q *Queries) GetAgentActionRequestBySessionAndRequest(ctx context.Context, arg GetAgentActionRequestBySessionAndRequestParams) (AgentActionRequest, error) {
	row := q.db.QueryRow(ctx, getAgentActionRequestBySessionAndRequest, arg.SessionID, arg.RequestID)
	var i AgentActionRequest
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.RequestID,
		&i.TurnID,
		&i.ActionType,
		&i.AmountCc,
		&i.ThoughtLog,
		&i.Accepted,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const getAgentEventOffsetBySessionID = `-- name: GetAgentEventOffsetBySessionID :one
SELECT session_id, last_event_id, updated_at
FROM agent_event_offsets
WHERE session_id = $1
`

func (q *Queries) GetAgentEventOffsetBySessionID(ctx context.Context, sessionID string) (AgentEventOffset, error) {
	row := q.db.QueryRow(ctx, getAgentEventOffsetBySessionID, sessionID)
	var i AgentEventOffset
	err := row.Scan(&i.SessionID, &i.LastEventID, &i.UpdatedAt)
	return i, err
}

const getAgentSessionByID = `-- name: GetAgentSessionByID :one
SELECT id, agent_id, room_id, table_id, seat_id, join_mode, status, expires_at, created_at, closed_at
FROM agent_sessions
WHERE id = $1
`

func (q *Queries) GetAgentSessionByID(ctx context.Context, id string) (AgentSession, error) {
	row := q.db.QueryRow(ctx, getAgentSessionByID, id)
	var i AgentSession
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.RoomID,
		&i.TableID,
		&i.SeatID,
		&i.JoinMode,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const insertAgentActionRequestIfAbsent = `-- name: InsertAgentActionRequestIfAbsent :execrows
INSERT INTO agent_action_requests (id, session_id, request_id, turn_id, action_type, amount_cc, thought_log, accepted, reason)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  NULLIF($7::text, ''),
  $8,
  NULLIF($9::text, '')
)
ON CONFLICT (session_id, request_id) DO NOTHING
`

type InsertAgentActionRequestIfAbsentParams struct {
	ID         string
	SessionID  string
	RequestID  string
	TurnID     string
	ActionType string
	AmountCc   pgtype.Int8
	ThoughtLog string
	Accepted   bool
	Reason     string
}

func (q *Queries) InsertAgentActionRequestIfAbsent(ctx context.Context, arg InsertAgentActionRequestIfAbsentParams) (int64, error) {
	result, err := q.db.Exec(ctx, insertAgentActionRequestIfAbsent,
		arg.ID,
		arg.SessionID,
		arg.RequestID,
		arg.TurnID,
		arg.ActionType,
		arg.AmountCc,
		arg.ThoughtLog,
		arg.Accepted,
		arg.Reason,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAgentSessionMatch = `-- name: UpdateAgentSessionMatch :execrows
UPDATE agent_sessions
SET table_id = $2, seat_id = $3, status = 'active'
WHERE id = $1
`

type UpdateAgentSessionMatchParams struct {
	ID      string
	TableID pgtype.Text
	SeatID  pgtype.Int4
}

func (q *Queries) UpdateAgentSessionMatch(ctx context.Context, arg UpdateAgentSessionMatchParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateAgentSessionMatch, arg.ID, arg.TableID, arg.SeatID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertAgentEventOffset = `-- name: UpsertAgentEventOffset :exec
INSERT INTO agent_event_offsets (session_id, last_event_id)
VALUES ($1, $2)
ON CONFLICT (session_id)
DO UPDATE SET last_event_id = EXCLUDED.last_event_id, updated_at = now()
`

type UpsertAgentEventOffsetParams struct {
	SessionID   string
	LastEventID string
}

func (q *Queries) UpsertAgentEventOffset(ctx context.Context, arg UpsertAgentEventOffsetParams) error {
	_, err := q.db.Exec(ctx, upsertAgentEventOffset, arg.SessionID, arg.LastEventID)
	return err
}
